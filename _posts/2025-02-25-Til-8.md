---
title: "[TIL] 내일배움캠프 본캠프 DAY7"
categories: [내일배움캠프, TIL]
tag: [개인 과제, 본캠프, Java, 객체지향, 메서드, 클래스]
date: 2025-02-25 21:00:00 +0900
toc_sticky: true
---
### TODO
***
✔️ 자바 기초 문법 다지기 1주차 완강

✔️ 자바 기초 문법 다지기 2주차 완강

✔️ TIL 작성

### 오늘 배운 것
***
#### 메서드
**메서드**
- 여러 개의 작은 명령문을 한 곳에 모아 사용하는 단위
- 함수, 기능이라고도 함
- 메서드는 호출부, 선언부로 나누어짐
- `호출부`
  - 메서드를 사용하는 곳
- `선언부`
  - 메서드가 정의되어 있는 곳
- 호출부의 매개변수를 통해 메서드 연산에 필요한 데이터 전달 가능
- 메서드 이름
  - 기능의 역할을 짐작할 수 있는 이름을 사용
  - 카멜케이스를 사용하며 주로 동사로 시작하는 것이 좋음
- `매개변수`
  - 작업을 수행할 때 필요한 데이터를 전달받는 공간 (변수)

```java
public class 클래스이름 {
  [반환자료형] [메서드이름] (매개변수) {
    // 작업 명령문들
  }
}
```

#### 클래스와 객체
**객체**
- 실제로 존재하는 것

**인스턴스화**
- 객체를 만드는 과정
- Java 메모리 상에 객체가 만들어짐

**클래스 구조**

```java
class 클래스 {
  // 1. 속성
  // 2. 생성자
  // 3. 기능
}
```

**속성**
- 객체는 속성을 작성하는 곳
- 객체를 생성해야 속성에 접근 가능
- 속성은 변수로 표현
- 객체를 통해 속성에 접근할 때 `객체가담긴변수.속성`으로 접근

**생성자**
- 객체를 만들 때 생성
- 생성자가 없으면 클래스를 객체화할 수 없음
- 클래스를 생성하면 기본 생성자는 자동으로 추가됨

**생성자 특징**
1. 반환 자료형이 없음
2. 클래스명과 이름이 똑같음
3. 여러 개가 존재할 수 있음

**기능**
- 메서드로 표현

**getter**
- 클래스의 속성을 가져올 때 사용되는 기능

**setter**
- 객체의 속성을 외부에서 설정할 수 있게 해주는 기능

#### JVM 메모리 영역
**Method Area**
- 프로그램 시작 시 정보가 저장됨
- 클래스 정보(.class)가 올라가는 곳
- 클래스의 메서드 정보, static 변수 등이 저장됨
- 모든 객체가 공유하는 공용 공간

**Stack Area**
- 선입후출(LIFO) 구조
- 메서드가 호출될 때마다 스택이 쌓임
- 최근에 호출된 메서드가 먼저 실행됨
- 메서드 내에 선언된 지역변수들이 저장되는 곳
- 메서드 실행이 끝나면 스택에서 제거됨

**Heap Area**
- new 키워드로 생성된 객체가 저장되는 곳
- 객체의 실제 데이터가 저장되고 데이터의 주소는 stack 영역에 저장됨

#### 래퍼클래스
**래퍼클래스**
- 기본자료형을 객체로 감싸는 클래스

| **기본 자료형 (Primitive Type)** | **래퍼 클래스 (Wrapper Class)** |
| --- | --- |
| `byte` | `Byte` |
| `short` | `Short` |
| `int`  | `Integer` |
| `long` | `Long` |
| `float` | `Float` |
| `double` | `Double` |
| `char` | `Character` |
| `boolean` | `Boolean` |

**기본형의 종류**

| **자료형** | **종류** | **범위** | **바이트** | **비트** |
| --- | --- | --- | --- | --- |
| **`boolean`** | 논리형 | true/false | 1 | 8 |
| **`char`** | 문자형 | 0 ~ 65535 유니코드 값 | 2 | 16 |
| **`byte`** | 정수형 | -128 ~ 127 | 1 | 8 |
| **`short`** | 정수형 | -32,768 ~ 32,767 | 2 | 16 |
| **`int`** | 정수형 | -2,147,483,648 ~ 2,147,483,647 | 4 | 32 |
| **`long`** | 정수형 | -9,233,372,036,854,775,808 ~9,233,372,036,854,775,807 | 8 | 64 |
| **`float`** | 실수형 | 약 소수점 6~7자리까지 | 4 | 32 |
| **`double`** | 실수형 | 약 소수점 15~17자리까지 | 8 | 64 |

**참조형**
- `참조형변수`
  - 변수에 객체가 담기는 것
- 참조형 변수는 데이터가 저장된 메모리 주소를 가리킴 → Heap 메모리 주소
- 객체, 배열 등이 참조형에 속함
- 래퍼클래스도 객체
  - 하지만 출력시 메모리 주소값이 나오지 않음

**래퍼클래스 사용하는 이유**
- 기본형은 객체처럼 속성, 기능을 가질 수 없음
- 하지만 객체는 기능을 제공할 수 있음

**오토박싱**
- 기본형 → 래퍼형으로 변환하는 과정
- Integer는 참조형이지만 기본형 int 값을 직접 대입 가능

**오토언박싱**
- 래퍼형 → 기본형으로 변환하는 과정

**기본형 vs 래퍼형**
- 래퍼형은 내부적으로 데이터를 감싸고 있기 때문에 연산시 불리
- 빠른 작업이 필요한 경우 기본형을 직접 활용하는 것이 좋음

#### static
**static**
- 객체(인스턴스)를 만들지 않고 클래스 이름만으로 바로 사용 가능
- 모든 객체가 같은 값을 공유
- static 변수와 메서드는 한 번만 생성되고 Method Area에 저장됨

**인스턴스 멤버**
- 객체를 만들때마다 생성되는 변수와 메서드
- 객체(인스턴스)를 생성한 후에만 사용할 수 있음
- 각 객체가 개별적으로 값을 가짐
- 인스턴스는 Heap Area에 저장됨

**인스턴스 메서드**
- 객체의 속성을 활용하는 메서드
- 객체가 생성된 후에만 사용 가능

**static 사용시 주의사항**
- static 변수와 메모리는 프로그램이 종료될 때까지 메모리에 유지됨
  - 너무 많은 static을 남용하면 메모리 낭비로 이어짐
- static 메서드에서는 인스턴스 변수에 접근할 수 없음
  - 인스턴스 멤버를 사용하기 위해서는 먼저 객체가 생성되어야 함

#### final
**final**
- 변수는 변경이 불가능
- 클래스는 상속할 수 없음
- 메서드 수정 불가 (오버라이딩 불가)

**상수**
- 변하지 않고 항상 일정한 값을 갖는 수
- Java에서 상수는 대문자로 표현하는 것이 관례
- 프로그램 실행중에 절대 변경되서는 안되기 때문에 static final 키워드를 사용해 선언

**불변객체**
- 내부 상태를 변경할 수 없는 객체
- final을 속성에 활용
- setter 없이 설계
- 변경이 필요한 경우 새로운 객체를 만들어야 함

#### 인터페이스
**인터페이스**
- 설계 표준
- 클래스가 따라야할 최소한의 공통 규칙을 정의하는 역할
- 인터페이스를 활용해서 최소한의 규격 정의
- 세부 구현은 각 클래스에서

```java
interface 클래스 {
  
}

class 클래스1 implements 클래스 {
  
}
```

**인터페이스의 다양한 기능**
- 인터페이스 다중구현
  - implements 키워드로 다수의 인터페이스를 구현할 수 있음
- 인터페이스 다중상속
  - extends 키워드로 상속을 구현할 수 있음

**인터페이스에 변수를 선언하는 경우**
- 변수 선언시 형식에 관계 없이 자동으로 상수로 선언됨
- public static final로 선언됨
- 구현체 없이도 활용 가능
- 인터페이스는 표준의 역할이므로 변수선언은 최소화하는 것이 좋음

#### 캡슐화
**캡슐화**
- 객체의 정보를 외부에서 직접 접근하지 못하게 보호하는 것
- 클래스 혹은 객체의 캡슐화는 접근제어자를 통해서 구현 가능

**접근제어자**
- 클래스, 변수, 메서드, 생성자의 접근 범위를 제한하는 키워드

| **접근제어자** | 클래스 내부 | 패키지 내부 | 상속한 클래스 | 전체 공개 |
| --- | --- | --- | --- | --- |
| **public** | ✅ | ✅ | ✅ | ✅ |
| **protected** | ✅ | ✅ | ✅ | ❌ |
| **default** | ✅ | ✅ | ❌ | ❌ |
| **private** | ✅ | ❌ | ❌ | ❌ |

**데이터 접근**
- 캡슐화가 잘 적용된 클래스는 내부 데이터를 private로 보호하고 있음
- 데이터 조회나 변경이 필요한 경우 getter와 setter를 이용

**getter**
- 데이터를 안전하게 접근하기 위해 이용

```java
public class Person {
  private String secret;

  public String getSecret() {
    return this.secret;
  }
}
public class Main {
  public static void main(String[] args) {
    Person p1 = new Person();
    String secret = p1.getSecret();
  }  
}
```

**setter**
- 데이터를 안전하게 설정/변경하기 위해 사용

```java
public class Person {
  private String secret;
  
  public void setSecret(String secret) {
    this.secret = secret;
  }
}

public class Main {
  public static void main(String[] args) {
    Person p1 = new Person();
    p1.setSecret("newPassword");
  }
}
```

#### 상속
**상속**
- 클래스간의 관계를 부모, 자식으로 바라보는 개념
- 상속받은 속성과 기능은 자식 클래스에서 재사용할 수 있고, 확장할 수 있음
- 추상화, 다형성을 구현하는데 잘 활용됨

**재사용성**
- 부모 클래스의 내용을 물려받아 그대로 재사용 가능

**super**
- 자식 클래스에서 부모 클래스의 멤버(변수, 메서드)에 접근할 때 사용하는 키워드
- 부모 클래스가 먼저 생성되어야 하므로 super()는 항상 자식 클래스 생성자의 첫 줄에 위치

**확장**
- 부모 클래스의 기능을 유지하면서 자식 클래스에서 기능을 확장할 수 있음
- 자식 클래스에서 새로운 메서드를 추가하면 됨

**재정의 (메서드 오버라이딩)**
- 부모 메서드를 자식 클래스에서 변경하여 재정의하는 것
- 오버라이드된 메서드에 @Override 키워드를 붙이는 것을 권장
- 메서드 이름, 매개변수, 반환타입이 완전히 동일해야 함

**추상클래스**
- 공통 기능을 제공하면서 하위 클래스에 특정 메서드 구현을 강제하기 위해 사용됨
- 객체를 생성할 목적이 아니라 "설계도" 역할을 할 때 적합함
- abstract 키워드로 클래스를 선언
- 추상클래스로 객체를 생성할 수 없음
- 일반 클래스처럼 변수와 메서드를 가질 수 없음

**추상클래스와 인터페이스의 차이**
- 상속이 계층적 구조를 선언하기 적합
- 인터페이스는 표준을 제공하는 데 적합
- 인터페이스는 인스턴스 변수를 선언할 수 없음
- 계층적 구조를 표현하면서 공통 속성과 기능을 재사용할 때 추상클래스를 사용하는 것이 적합

#### 추상화
**추상화**
- 불필요한 정보를 제거하고 본질적인 특징만 남기는 것
- 계층적 특징을 활용해 유지보수성이 좋은 프로그램 만들기 가능

#### 다형성
**다형성**
- 하나의 타입으로 여러 객체를 다룰 수 있는 것
- 인터페이스 상속, 클래스 상속을 활용해 추상 계층을 표현함
- 추상 계층을 통해 다형성 구현 가능

**형변환**
- 자식타입 → 부모타입: 업캐스팅(`UpCasting`)
  - 부모의 타입으로 데이터를 다룰 수 있지만 자식 클래스의 고유기능 활용 불가
    - 자식 클래스의 고유 기능을 사용하려면 다운캐스팅 필요
- 부모타입 → 자식타입: 다운캐스팅(`DownCasting`)
  - 잘못된 다운캐스팅은 컴파일단계에서 감지 불가
    - instanceof를 활용해야 함
      - 객체가 특정 클래스나 인터페이스의 인스턴스인지 확인해줌

### 느낀점
***
처음에는 ‘12시간이나 어떻게 하지?’ 싶었는데, 특강과 인강을 듣다 보니 시간이 생각보다 훨씬 빨리 지나갔다. 앞으로는 좀 더 구체적으로 시간을 분배할 필요가 있을 것 같다. 그리고 오늘 개인 과제가 발제되었으니, 내일부터 본격적으로 시작해야겠다!

### 내일 학습할 것
- 자바 기초 문법 2주차 정리하기
- 계산기 과제 시작하기
- TIL 작성하기
