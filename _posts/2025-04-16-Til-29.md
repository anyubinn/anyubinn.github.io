---
title: "[TIL] DAY42 JPA 연관관계 매핑"
categories: [내일배움캠프, TIL]
tag: [개인 과제, 본캠프, JPA, 연관관계 매핑, Java, Spring Boot, Entity]
date: 2025-04-16 15:10:00 +0900
toc_sticky: true
---
## 오늘 배운 것
***
### 1:N 연관관계
JPA에서는 데이터베이스 테이블 간의 관계를 객체 지향적으로 표현할 수 있도록 **연관관계 매핑** 기능을 제공한다. 이를 통해 SQL을 직접 작성하지 않고도 객체 간의 관계를 이용해 데이터를 조회하고 조작할 수 있다.

#### 📌 연관관계 매핑 개요
- 종류: `N:1`, `1:N`, `1:1`, `N:M`
- 방향: 단방향, 양방향
- 연관관계의 주인: 외래 키(FK)를 가진 쪽 (수정권한 보유)

> DB는 외래 키만으로 자유롭게 JOIN이 가능하지만, 객체는 참조를 통한 접근만 가능하므로 방향성을 고려해야 함

***
#### 🔍 1:N 단방향 매핑
##### 💡 개념
- 한 엔티티가 여러 엔티티를 리스트로 참조함
- 연관관계의 주인은 `1`쪽이지만, 실제 외래 키는 `N` 테이블에 있어 추가적인 UPDATE가 발생함

##### ✅ 코드 예시

```java
@Entity
public class Company {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany
    @JoinColumn(name = "company_id") // 외래 키 지정
    private List<Tutor> tutors = new ArrayList<>();
}
```
```java
@Entity
public class Tutor {
    @Id @GeneratedValue
    private Long id;
    private String name;
}
```

##### ⚠️ 단점
- DB는 외래 키를 `N` 테이블에 설정해야 하므로 `Company`가 `Tutor`의 외래 키를 수정하려면 **추가적은 UPDATE 쿼리**가 발생
- `@JoinColumn`을 생략하면 **중간 테이블** 방식이 되어 의도와 다른 매핑이 생성됨

> 유지보수성과 성능을 고려하면 `N:1 양방향` 매핑이 더 적합함

***
#### 🔄 1:N 양방향 매핑
##### 💡 개념
- `Company`가 `Tutor`를 리스트로, `Tutor`는 `Company`를 단일 객체로 참조함
- 단, 연관관계의 주인은 외래 키를 가진 `Tutor`

##### ✅ 코드 예시

```java
@Entity
public class Tutor {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @ManyToOne
    @JoinColumn(name = "company_id", insertable = false, updatable = false) // 읽기 전용
    private Company company;
}
```

> `insertable=false`, `updatable=false` 옵션을 주어 연관관계의 주인이 아님을 명확히 함

***
### 1:1 연관관계
#### 📌 1:1 단방향 연관관계

> 두 엔티티가 `@OneToOne`을 통해 연관을 맺되, 한쪽만 참조하는 구조

##### 💡 개념
- 외래 키의 주인은 `Tutor`로 설정
- 외래 키에 `UNIQUE` 제약조건 필수

##### ✅ 코드 예시

```java
@Entity
@Table(name = "address")
public class Address {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}
```
```java
@Entity
@Table(name = "tutor")
public class Tutor {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  @OneToOne
  @JoinColumn(name = "address_id", unique = true)
  private Address address;

}
```

> 📌 단방향일 경우, 외래 키가 있는 `Tutor`만 `Address`를 참조할 수 있음

***
#### 📌 1:1 양방향 연관관계

> 양쪽 엔티티가 서로를 참조하는 구조<br>
> 외래 키가 있는 곳이 연관관계의 주인

##### ✅ 코드 예시

```java
@Entity
@Table(name = "address")
public class Address {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne(mappedBy = "address")
    private Tutor tutor;

}
```
```java
@Entity
@Table(name = "tutor")
public class Tutor {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String name;

  @OneToOne
  @JoinColumn(name = "address_id", unique = true)
  private Address address;

}
```

> 📌 `Address` 입장에서는 읽기 전용 필드로 작동

***
#### ⚖️ 외래 키 위치에 따른 설계 전략

> 1:1 연관관계에서는 외래 키를 어느 테이블에 둘지 선택할 수 있음

##### 📌 예시: `Tutor`가 `Address`를 가짐
- 외래 키를 `Tutor`가 가지고 있다면
  - 단방향 또는 양방향 설정 가능
  - `Tutor`에서 `Address`를 쉽게 조회 가능
- 외래 키를 `Address`가 가지고 있다면
  - `Tutor`에서 접근이 어려움(읽기 전용)
  - 무결성은 더 잘 보장됨

***
##### 🔄 요구사항 변경 대응

> 예: `Tutor`가 여러 개의 `Address`를 가지는 경우

**기존 구조**
![image](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fc7b23557-e6f0-403e-be65-d3fa814147ef%2Fimage.png?table=block&id=291c183d-cb6e-4372-a33a-3218adce74ae&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=580&userId=&cache=v2)

**변경 후 구조**
![image](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F4542ee6a-b20e-4fbc-87ef-183179447376%2Fimage.png?table=block&id=e6b7aad1-a70b-43dc-a952-4887dd9da93c&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=580&userId=&cache=v2)

- `UNIQUE` 제약조건을 제거하면 자연스럽게 `1:N`으로 확장 가능
- 양방향 연관관계로 설정해야 활용도가 높아짐

***
#### 📊 외래 키 위치의 장단점

| 구분                   | 주 테이블에 외래 키                                | 대상 테이블에 외래 키                             |
|------------------------|----------------------------------------------------|---------------------------------------------------|
| 장점                   | JPA 활용이 쉬움, 객체 그래프 탐색 용이            | 무결성 보장, 구조 변경에 유연                     |
| 단점                   | `null` 허용, 삭제 시 처리 복잡                    | 즉시 로딩 강제, 매핑 복잡, 성능 저하 가능         |

***
### N:M 연관관계
JPA에서는 `@ManyToMany`를 통해 두 엔티티 간의 N:M(다대다) 관계를 표현할 수 있다. 하지만 실제 개발에서는 중간 테이블을 명시적으로 만들어 관리하는 방식이 더 유연하고 실용적이다.

***
#### 📌 N:M 연관관계란?

> 두 엔티티가 서로 여러 개의 인스턴스를 참조하는 구조

- 여러 명의 **튜터**가 여러 개의 **프로그래밍 언어**를 사용할 수 있음
- 객체 구조에서는 컬랙션을 통해 단순히 표현할 수 있음
- 관계형 데이터베이스에서는 `중간 테이블`을 통해 `1:N`, `N:1` 관계로 풀어내야 함

***
#### ✅ N:M 단방향 코드 예시

```java
@Entity
@Table(name = "language")
public class Language {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
}
```
```java
@Entity
@Table(name = "tutor")
public class Tutor {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String name;

  @ManyToMany
  @JoinTable(
    name = "tutor_language",
    joinColumns = @JoinColumn(name = "tutor_id"),
    inverseJoinColumns = @JoinColumn(name = "language_id")
  )
  private List<Language> languages = new ArrayList<>();
}
```

> 📌 단방향으로만 설정된 경우, `Tutor`만 `Language`를 참조할 수 있음

***
#### ✅ N:M 양방향 코드 예시

```java
@Entity
@Table(name = "language")
public class Language {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @ManyToMany(mappedBy = "languages")
    private List<Tutor> tutors = new ArrayList<>();
}
```

- `mappedBy`를 통해 양방향 연관관계를 설정
- 내부적으로는 `tutor_language`라는 **중간 테이블**이 자동으로 생성됨

***
#### ⚠️ @ManyToMany의 문제점
![image](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2Fd425a4e9-607c-4014-87e6-0be41d472608%2Fimage.png?table=block&id=eca2bc88-8b03-44d4-9994-5a048786df1b&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=770&userId=&cache=v2)
- 중간 테이블에 **추가 컬럼(level, license 등)**을 넣을 수 없음
- SQL 쿼리가 예측하기 어려워짐
- 중간 테이블의 PK가 복합키(`tutor_id`, `language_id`)로 설정되어 유연성이 떨어짐

##### 💡 중간 테이블을 엔티티로 분리
![image](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F83c75a39-3aba-4ba4-a792-7aefe4b07895%2F63a3e756-7b01-4f20-ab09-17bf24cfb28f%2Fimage.png?table=block&id=a60fd640-e649-4f93-b25c-ea05b5e266b3&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=770&userId=&cache=v2)

> `@ManyToMany`를 사용하지 않고, 중간 테이블을 명시적인 엔티티로 분리

**🔧 중간 엔티티**

```java
@Entity
@Table(name = "tutor_language")
public class TutorLanguage {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "tutor_id")
    private Tutor tutor;

    @ManyToOne
    @JoinColumn(name = "language_id")
    private Language language;

    private Integer level;
    private String license;
}
```

**🧩 양쪽 엔티티에서의 매핑**

```java
@Entity
@Table(name = "tutor")
public class Tutor {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = "tutor")
    private List<TutorLanguage> tutorLanguages = new ArrayList<>();
}
```
```java
@Entity
@Table(name = "language")
public class Language {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @OneToMany(mappedBy = "language")
    private List<TutorLanguage> tutorLanguages = new ArrayList<>();
}
```
